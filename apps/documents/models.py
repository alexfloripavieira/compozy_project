"""
Documents models for PRD and Tech Spec storage.

This module contains models for storing and versioning documents
generated by the AI agents during the problem-solving workflow.
"""
import uuid
import difflib
from django.db import models
from django.urls import reverse
from django.contrib.auth import get_user_model

from apps.common.models import TimestampedModel
from apps.problems.models import Problem

User = get_user_model()


class PRDDocument(TimestampedModel):
    """
    Product Requirements Document (PRD) model with versioning support.

    PRD documents are generated by the BusinessAnalystAgent and contain
    the business requirements and specifications for a problem.

    Each problem can have multiple versions of a PRD, allowing for
    iterative refinement based on user feedback.

    Attributes:
        id: UUID primary key
        problem: The problem this PRD belongs to
        version: Version number (increments for each revision)
        content: The markdown content of the PRD
        summary: Brief summary of the PRD
        created_by: User who requested this version (or None if auto-generated)
        is_approved: Whether this version has been approved by the user
        approved_at: When the PRD was approved
        approved_by: User who approved the PRD
        parent_version: Reference to the previous version (for version history)
        change_notes: Notes describing changes from previous version
    """

    # Status choices for the document
    STATUS_CHOICES = [
        ('draft', 'Rascunho'),
        ('pending_review', 'Aguardando Revisao'),
        ('revision_requested', 'Revisao Solicitada'),
        ('approved', 'Aprovado'),
        ('rejected', 'Rejeitado'),
    ]

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False
    )
    problem = models.ForeignKey(
        Problem,
        on_delete=models.CASCADE,
        related_name='prd_documents',
        verbose_name='problema',
        help_text='Problema ao qual este PRD pertence'
    )
    version = models.PositiveIntegerField(
        'versao',
        default=1,
        help_text='Numero da versao do documento'
    )
    content = models.TextField(
        'conteudo',
        help_text='Conteudo do PRD em formato Markdown'
    )
    summary = models.TextField(
        'resumo',
        blank=True,
        default='',
        help_text='Resumo breve do PRD'
    )
    status = models.CharField(
        'status',
        max_length=20,
        choices=STATUS_CHOICES,
        default='draft',
        db_index=True,
        help_text='Status atual do documento'
    )
    created_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='created_prd_documents',
        verbose_name='criado por',
        help_text='Usuario que solicitou esta versao'
    )
    is_approved = models.BooleanField(
        'aprovado',
        default=False,
        help_text='Se esta versao foi aprovada pelo usuario'
    )
    approved_at = models.DateTimeField(
        'aprovado em',
        null=True,
        blank=True,
        help_text='Data e hora da aprovacao'
    )
    approved_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='approved_prd_documents',
        verbose_name='aprovado por',
        help_text='Usuario que aprovou o documento'
    )
    parent_version = models.ForeignKey(
        'self',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='child_versions',
        verbose_name='versao anterior',
        help_text='Referencia a versao anterior do documento'
    )
    change_notes = models.TextField(
        'notas de alteracao',
        blank=True,
        default='',
        help_text='Descricao das alteracoes em relacao a versao anterior'
    )
    word_count = models.PositiveIntegerField(
        'contagem de palavras',
        default=0,
        help_text='Numero de palavras no documento'
    )

    class Meta:
        verbose_name = 'Documento PRD'
        verbose_name_plural = 'Documentos PRD'
        ordering = ['-version', '-created_at']
        db_table = 'documents_prd'
        indexes = [
            models.Index(fields=['problem', 'version']),
            models.Index(fields=['problem', 'status']),
            models.Index(fields=['problem', 'is_approved']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['problem', 'version'],
                name='unique_prd_version_per_problem'
            )
        ]

    def __str__(self):
        return f'PRD v{self.version} - {self.problem.title}'

    def get_absolute_url(self):
        """Return the URL for this PRD's detail page."""
        return reverse('documents:prd_detail', kwargs={
            'org_slug': self.problem.organization.slug,
            'problem_pk': self.problem.pk,
            'pk': self.pk
        })

    def save(self, *args, **kwargs):
        """Override save to auto-calculate word count."""
        if self.content:
            self.word_count = len(self.content.split())
        super().save(*args, **kwargs)

    def compare_versions(self, other_version):
        """
        Compare this PRD version with another version.

        Generates a unified diff between the two versions showing
        additions, deletions, and changes.

        Args:
            other_version: Another PRDDocument instance to compare with.

        Returns:
            dict: A dictionary containing:
                - diff_lines: List of diff lines in unified diff format
                - additions: Number of lines added
                - deletions: Number of lines removed
                - similarity_ratio: Percentage of similarity (0-100)

        Raises:
            ValueError: If other_version is not a PRDDocument instance
                        or belongs to a different problem.
        """
        if not isinstance(other_version, PRDDocument):
            raise ValueError("other_version must be a PRDDocument instance")

        if other_version.problem_id != self.problem_id:
            raise ValueError("Cannot compare PRDs from different problems")

        # Split content into lines for comparison
        self_lines = self.content.splitlines(keepends=True)
        other_lines = other_version.content.splitlines(keepends=True)

        # Generate unified diff
        diff = list(difflib.unified_diff(
            other_lines,
            self_lines,
            fromfile=f'v{other_version.version}',
            tofile=f'v{self.version}',
            lineterm=''
        ))

        # Count additions and deletions
        additions = sum(1 for line in diff if line.startswith('+') and not line.startswith('+++'))
        deletions = sum(1 for line in diff if line.startswith('-') and not line.startswith('---'))

        # Calculate similarity ratio
        matcher = difflib.SequenceMatcher(None, self.content, other_version.content)
        similarity_ratio = round(matcher.ratio() * 100, 2)

        return {
            'diff_lines': diff,
            'additions': additions,
            'deletions': deletions,
            'similarity_ratio': similarity_ratio,
            'from_version': other_version.version,
            'to_version': self.version,
        }

    def get_diff_from_parent(self):
        """
        Get the diff between this version and its parent version.

        Returns:
            dict or None: Diff result if parent exists, None otherwise.
        """
        if self.parent_version:
            return self.compare_versions(self.parent_version)
        return None

    def approve(self, user):
        """
        Approve this PRD version.

        Args:
            user: The user approving the document.
        """
        from django.utils import timezone
        self.is_approved = True
        self.status = 'approved'
        self.approved_at = timezone.now()
        self.approved_by = user
        self.save(update_fields=['is_approved', 'status', 'approved_at', 'approved_by', 'updated_at'])

    def request_revision(self, notes=''):
        """
        Mark this PRD as needing revision.

        Args:
            notes: Notes describing what needs to be revised.
        """
        self.status = 'revision_requested'
        if notes:
            self.change_notes = notes
        self.save(update_fields=['status', 'change_notes', 'updated_at'])

    def reject(self, user, reason=''):
        """
        Reject this PRD version.

        Args:
            user: The user rejecting the document.
            reason: Reason for rejection.
        """
        self.status = 'rejected'
        if reason:
            self.change_notes = reason
        self.save(update_fields=['status', 'change_notes', 'updated_at'])

    @classmethod
    def create_new_version(cls, problem, content, created_by=None, change_notes=''):
        """
        Create a new version of the PRD for a problem.

        Automatically increments the version number and links to
        the previous version if one exists.

        Args:
            problem: The Problem instance.
            content: The markdown content for the new version.
            created_by: User creating this version (optional).
            change_notes: Notes describing changes from previous version.

        Returns:
            PRDDocument: The newly created PRD document.
        """
        # Get the latest version for this problem
        latest = cls.objects.filter(problem=problem).order_by('-version').first()

        new_version = 1
        parent = None
        if latest:
            new_version = latest.version + 1
            parent = latest

        return cls.objects.create(
            problem=problem,
            version=new_version,
            content=content,
            created_by=created_by,
            parent_version=parent,
            change_notes=change_notes,
            status='pending_review'
        )

    @classmethod
    def get_latest_for_problem(cls, problem):
        """
        Get the latest PRD version for a problem.

        Args:
            problem: The Problem instance.

        Returns:
            PRDDocument or None: The latest PRD document if exists.
        """
        return cls.objects.filter(problem=problem).order_by('-version').first()

    @classmethod
    def get_approved_for_problem(cls, problem):
        """
        Get the approved PRD for a problem.

        Args:
            problem: The Problem instance.

        Returns:
            PRDDocument or None: The approved PRD document if exists.
        """
        return cls.objects.filter(
            problem=problem,
            is_approved=True
        ).order_by('-version').first()


class TechSpecDocument(TimestampedModel):
    """
    Technical Specification Document model with versioning support.

    Tech Spec documents are generated by the TechArchitectAgent and contain
    the technical architecture, implementation details, and recommendations
    for solving a problem.

    Each problem can have multiple versions of a Tech Spec, allowing for
    iterative refinement based on user feedback and PRD changes.

    Attributes:
        id: UUID primary key
        problem: The problem this Tech Spec belongs to
        prd_document: The PRD this Tech Spec is based on
        version: Version number (increments for each revision)
        content: The markdown content of the Tech Spec
        summary: Brief summary of the Tech Spec
        architecture_overview: High-level architecture description
        created_by: User who requested this version (or None if auto-generated)
        is_approved: Whether this version has been approved by the user
        approved_at: When the Tech Spec was approved
        approved_by: User who approved the Tech Spec
        parent_version: Reference to the previous version (for version history)
        change_notes: Notes describing changes from previous version
    """

    # Status choices for the document
    STATUS_CHOICES = [
        ('draft', 'Rascunho'),
        ('pending_review', 'Aguardando Revisao'),
        ('revision_requested', 'Revisao Solicitada'),
        ('approved', 'Aprovado'),
        ('rejected', 'Rejeitado'),
    ]

    # Complexity choices
    COMPLEXITY_CHOICES = [
        ('low', 'Baixa'),
        ('medium', 'Media'),
        ('high', 'Alta'),
        ('very_high', 'Muito Alta'),
    ]

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False
    )
    problem = models.ForeignKey(
        Problem,
        on_delete=models.CASCADE,
        related_name='tech_spec_documents',
        verbose_name='problema',
        help_text='Problema ao qual esta especificacao tecnica pertence'
    )
    prd_document = models.ForeignKey(
        PRDDocument,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='tech_specs',
        verbose_name='documento PRD',
        help_text='PRD no qual esta especificacao tecnica se baseia'
    )
    version = models.PositiveIntegerField(
        'versao',
        default=1,
        help_text='Numero da versao do documento'
    )
    content = models.TextField(
        'conteudo',
        help_text='Conteudo da especificacao tecnica em formato Markdown'
    )
    summary = models.TextField(
        'resumo',
        blank=True,
        default='',
        help_text='Resumo breve da especificacao tecnica'
    )
    architecture_overview = models.TextField(
        'visao geral da arquitetura',
        blank=True,
        default='',
        help_text='Descricao de alto nivel da arquitetura proposta'
    )
    estimated_complexity = models.CharField(
        'complexidade estimada',
        max_length=10,
        choices=COMPLEXITY_CHOICES,
        default='medium',
        help_text='Nivel de complexidade estimado para implementacao'
    )
    estimated_tasks = models.PositiveIntegerField(
        'tarefas estimadas',
        default=0,
        help_text='Numero estimado de tarefas para implementacao'
    )
    technologies = models.JSONField(
        'tecnologias',
        default=list,
        blank=True,
        help_text='Lista de tecnologias e bibliotecas recomendadas'
    )
    status = models.CharField(
        'status',
        max_length=20,
        choices=STATUS_CHOICES,
        default='draft',
        db_index=True,
        help_text='Status atual do documento'
    )
    created_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='created_tech_spec_documents',
        verbose_name='criado por',
        help_text='Usuario que solicitou esta versao'
    )
    is_approved = models.BooleanField(
        'aprovado',
        default=False,
        help_text='Se esta versao foi aprovada pelo usuario'
    )
    approved_at = models.DateTimeField(
        'aprovado em',
        null=True,
        blank=True,
        help_text='Data e hora da aprovacao'
    )
    approved_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='approved_tech_spec_documents',
        verbose_name='aprovado por',
        help_text='Usuario que aprovou o documento'
    )
    parent_version = models.ForeignKey(
        'self',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='child_versions',
        verbose_name='versao anterior',
        help_text='Referencia a versao anterior do documento'
    )
    change_notes = models.TextField(
        'notas de alteracao',
        blank=True,
        default='',
        help_text='Descricao das alteracoes em relacao a versao anterior'
    )
    word_count = models.PositiveIntegerField(
        'contagem de palavras',
        default=0,
        help_text='Numero de palavras no documento'
    )

    class Meta:
        verbose_name = 'Especificacao Tecnica'
        verbose_name_plural = 'Especificacoes Tecnicas'
        ordering = ['-version', '-created_at']
        db_table = 'documents_tech_spec'
        indexes = [
            models.Index(fields=['problem', 'version']),
            models.Index(fields=['problem', 'status']),
            models.Index(fields=['problem', 'is_approved']),
            models.Index(fields=['prd_document', 'version']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['problem', 'version'],
                name='unique_tech_spec_version_per_problem'
            )
        ]

    def __str__(self):
        return f'Tech Spec v{self.version} - {self.problem.title}'

    def get_absolute_url(self):
        """Return the URL for this Tech Spec's detail page."""
        return reverse('documents:tech_spec_detail', kwargs={
            'org_slug': self.problem.organization.slug,
            'problem_pk': self.problem.pk,
            'pk': self.pk
        })

    def save(self, *args, **kwargs):
        """Override save to auto-calculate word count."""
        if self.content:
            self.word_count = len(self.content.split())
        super().save(*args, **kwargs)

    def compare_versions(self, other_version):
        """
        Compare this Tech Spec version with another version.

        Generates a unified diff between the two versions showing
        additions, deletions, and changes.

        Args:
            other_version: Another TechSpecDocument instance to compare with.

        Returns:
            dict: A dictionary containing:
                - diff_lines: List of diff lines in unified diff format
                - additions: Number of lines added
                - deletions: Number of lines removed
                - similarity_ratio: Percentage of similarity (0-100)

        Raises:
            ValueError: If other_version is not a TechSpecDocument instance
                        or belongs to a different problem.
        """
        if not isinstance(other_version, TechSpecDocument):
            raise ValueError("other_version must be a TechSpecDocument instance")

        if other_version.problem_id != self.problem_id:
            raise ValueError("Cannot compare Tech Specs from different problems")

        # Split content into lines for comparison
        self_lines = self.content.splitlines(keepends=True)
        other_lines = other_version.content.splitlines(keepends=True)

        # Generate unified diff
        diff = list(difflib.unified_diff(
            other_lines,
            self_lines,
            fromfile=f'v{other_version.version}',
            tofile=f'v{self.version}',
            lineterm=''
        ))

        # Count additions and deletions
        additions = sum(1 for line in diff if line.startswith('+') and not line.startswith('+++'))
        deletions = sum(1 for line in diff if line.startswith('-') and not line.startswith('---'))

        # Calculate similarity ratio
        matcher = difflib.SequenceMatcher(None, self.content, other_version.content)
        similarity_ratio = round(matcher.ratio() * 100, 2)

        return {
            'diff_lines': diff,
            'additions': additions,
            'deletions': deletions,
            'similarity_ratio': similarity_ratio,
            'from_version': other_version.version,
            'to_version': self.version,
        }

    def get_diff_from_parent(self):
        """
        Get the diff between this version and its parent version.

        Returns:
            dict or None: Diff result if parent exists, None otherwise.
        """
        if self.parent_version:
            return self.compare_versions(self.parent_version)
        return None

    def approve(self, user):
        """
        Approve this Tech Spec version.

        Args:
            user: The user approving the document.
        """
        from django.utils import timezone
        self.is_approved = True
        self.status = 'approved'
        self.approved_at = timezone.now()
        self.approved_by = user
        self.save(update_fields=['is_approved', 'status', 'approved_at', 'approved_by', 'updated_at'])

    def request_revision(self, notes=''):
        """
        Mark this Tech Spec as needing revision.

        Args:
            notes: Notes describing what needs to be revised.
        """
        self.status = 'revision_requested'
        if notes:
            self.change_notes = notes
        self.save(update_fields=['status', 'change_notes', 'updated_at'])

    def reject(self, reason=''):
        """
        Reject this Tech Spec version.

        Args:
            reason: Reason for rejection.
        """
        self.status = 'rejected'
        if reason:
            self.change_notes = reason
        self.save(update_fields=['status', 'change_notes', 'updated_at'])

    @classmethod
    def create_new_version(cls, problem, content, prd_document=None, created_by=None, change_notes=''):
        """
        Create a new version of the Tech Spec for a problem.

        Automatically increments the version number and links to
        the previous version if one exists.

        Args:
            problem: The Problem instance.
            content: The markdown content for the new version.
            prd_document: The PRD document this Tech Spec is based on (optional).
            created_by: User creating this version (optional).
            change_notes: Notes describing changes from previous version.

        Returns:
            TechSpecDocument: The newly created Tech Spec document.
        """
        # Get the latest version for this problem
        latest = cls.objects.filter(problem=problem).order_by('-version').first()

        new_version = 1
        parent = None
        if latest:
            new_version = latest.version + 1
            parent = latest

        return cls.objects.create(
            problem=problem,
            prd_document=prd_document,
            version=new_version,
            content=content,
            created_by=created_by,
            parent_version=parent,
            change_notes=change_notes,
            status='pending_review'
        )

    @classmethod
    def get_latest_for_problem(cls, problem):
        """
        Get the latest Tech Spec version for a problem.

        Args:
            problem: The Problem instance.

        Returns:
            TechSpecDocument or None: The latest Tech Spec document if exists.
        """
        return cls.objects.filter(problem=problem).order_by('-version').first()

    @classmethod
    def get_approved_for_problem(cls, problem):
        """
        Get the approved Tech Spec for a problem.

        Args:
            problem: The Problem instance.

        Returns:
            TechSpecDocument or None: The approved Tech Spec document if exists.
        """
        return cls.objects.filter(
            problem=problem,
            is_approved=True
        ).order_by('-version').first()
