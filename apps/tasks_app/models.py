"""
Task models for the Compozy project.

This module contains the Task model which represents executable work units
generated from technical specifications. Tasks can have dependencies on
other tasks and go through a workflow of states.
"""
import uuid
from django.db import models
from django.urls import reverse
from django.utils import timezone
from django.core.exceptions import ValidationError

from apps.common.models import TimestampedModel
from apps.problems.models import Problem
from apps.documents.models import TechSpecDocument


class Task(TimestampedModel):
    """
    Task model representing an executable work unit.

    Tasks are generated by the TaskPlannerAgent based on a TechSpecDocument.
    Each task represents a discrete unit of work that can be executed by
    the CodeWriterAgent.

    Tasks can have dependencies on other tasks, meaning they cannot be
    executed until their dependencies are completed.

    Attributes:
        id: UUID primary key
        problem: The problem this task belongs to
        tech_spec: The tech spec this task was generated from
        title: Brief title describing the task
        description: Detailed description of what needs to be done
        spec: Detailed specification for the task implementation
        order_index: Order in which tasks should be executed
        dependencies: Other tasks that must complete before this one
        status: Current status of the task
        implementation: JSON field storing implementation details
        test_results: JSON field storing test execution results
        started_at: When task execution started
        completed_at: When task was completed
        error_message: Error message if task failed
        branch_name: Git branch name for this task's changes
        commit_sha: Git commit SHA for this task's changes
    """

    # Status workflow choices
    STATUS_CHOICES = [
        ('pending', 'Pendente'),
        ('selected', 'Selecionado'),
        ('in_progress', 'Em Progresso'),
        ('testing', 'Testando'),
        ('completed', 'Concluido'),
        ('failed', 'Falhou'),
        ('skipped', 'Pulado'),
    ]

    # Priority choices
    PRIORITY_CHOICES = [
        ('low', 'Baixa'),
        ('medium', 'Media'),
        ('high', 'Alta'),
        ('critical', 'Critica'),
    ]

    # Task type choices
    TYPE_CHOICES = [
        ('feature', 'Feature'),
        ('bugfix', 'Bugfix'),
        ('refactor', 'Refatoracao'),
        ('test', 'Teste'),
        ('documentation', 'Documentacao'),
        ('config', 'Configuracao'),
    ]

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False
    )
    problem = models.ForeignKey(
        Problem,
        on_delete=models.CASCADE,
        related_name='tasks',
        verbose_name='problema',
        help_text='Problema ao qual esta tarefa pertence'
    )
    tech_spec = models.ForeignKey(
        TechSpecDocument,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='tasks',
        verbose_name='especificacao tecnica',
        help_text='Especificacao tecnica da qual esta tarefa foi gerada'
    )
    title = models.CharField(
        'titulo',
        max_length=500,
        help_text='Titulo breve descrevendo a tarefa'
    )
    description = models.TextField(
        'descricao',
        blank=True,
        default='',
        help_text='Descricao detalhada do que precisa ser feito'
    )
    spec = models.TextField(
        'especificacao',
        blank=True,
        default='',
        help_text='Especificacao detalhada para implementacao da tarefa'
    )
    order_index = models.PositiveIntegerField(
        'ordem',
        default=0,
        db_index=True,
        help_text='Ordem de execucao da tarefa'
    )
    dependencies = models.ManyToManyField(
        'self',
        symmetrical=False,
        blank=True,
        related_name='dependent_tasks',
        verbose_name='dependencias',
        help_text='Tarefas que devem ser concluidas antes desta'
    )
    status = models.CharField(
        'status',
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        db_index=True,
        help_text='Status atual da tarefa'
    )
    priority = models.CharField(
        'prioridade',
        max_length=10,
        choices=PRIORITY_CHOICES,
        default='medium',
        db_index=True,
        help_text='Nivel de prioridade da tarefa'
    )
    task_type = models.CharField(
        'tipo',
        max_length=20,
        choices=TYPE_CHOICES,
        default='feature',
        help_text='Tipo da tarefa'
    )
    implementation = models.JSONField(
        'implementacao',
        default=dict,
        blank=True,
        help_text='Detalhes da implementacao em formato JSON'
    )
    test_results = models.JSONField(
        'resultados de teste',
        default=list,
        blank=True,
        help_text='Resultados dos testes em formato JSON'
    )
    started_at = models.DateTimeField(
        'iniciado em',
        null=True,
        blank=True,
        help_text='Data e hora de inicio da execucao'
    )
    completed_at = models.DateTimeField(
        'concluido em',
        null=True,
        blank=True,
        help_text='Data e hora de conclusao'
    )
    error_message = models.TextField(
        'mensagem de erro',
        blank=True,
        default='',
        help_text='Mensagem de erro se a tarefa falhou'
    )
    branch_name = models.CharField(
        'nome da branch',
        max_length=255,
        blank=True,
        default='',
        help_text='Nome da branch Git para as alteracoes desta tarefa'
    )
    commit_sha = models.CharField(
        'SHA do commit',
        max_length=40,
        blank=True,
        default='',
        help_text='SHA do commit Git com as alteracoes'
    )
    estimated_hours = models.DecimalField(
        'horas estimadas',
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        help_text='Tempo estimado em horas para completar a tarefa'
    )
    actual_hours = models.DecimalField(
        'horas reais',
        max_digits=5,
        decimal_places=2,
        null=True,
        blank=True,
        help_text='Tempo real gasto em horas'
    )

    class Meta:
        verbose_name = 'Tarefa'
        verbose_name_plural = 'Tarefas'
        ordering = ['order_index', '-created_at']
        db_table = 'tasks_task'
        indexes = [
            models.Index(fields=['problem', 'status']),
            models.Index(fields=['problem', 'order_index']),
            models.Index(fields=['tech_spec', 'status']),
            models.Index(fields=['status', 'priority']),
        ]

    def __str__(self):
        return f'{self.title} - {self.get_status_display()}'

    def get_absolute_url(self):
        """Return the URL for this task's detail page."""
        return reverse('tasks_app:detail', kwargs={
            'org_slug': self.problem.organization.slug,
            'problem_pk': self.problem.pk,
            'pk': self.pk
        })

    def clean(self):
        """Validate the task model."""
        super().clean()
        self.validate_dependencies()

    def validate_dependencies(self):
        """
        Validate that task dependencies are valid.

        Checks for:
        - Self-referencing dependencies
        - Circular dependencies
        - Dependencies from different problems

        Raises:
            ValidationError: If any validation fails.
        """
        if not self.pk:
            # New task, can't have dependencies yet
            return

        # Get all dependencies
        dependencies = self.dependencies.all()

        for dep in dependencies:
            # Check for self-reference
            if dep.pk == self.pk:
                raise ValidationError({
                    'dependencies': 'Uma tarefa nao pode depender de si mesma.'
                })

            # Check for different problem
            if dep.problem_id != self.problem_id:
                raise ValidationError({
                    'dependencies': f'A dependencia "{dep.title}" pertence a um problema diferente.'
                })

            # Check for circular dependencies
            if self._has_circular_dependency(dep):
                raise ValidationError({
                    'dependencies': f'Dependencia circular detectada com a tarefa "{dep.title}".'
                })

    def _has_circular_dependency(self, dependency, visited=None):
        """
        Check if adding a dependency would create a circular reference.

        Args:
            dependency: The task to check for circular dependency.
            visited: Set of already visited task IDs.

        Returns:
            bool: True if circular dependency exists.
        """
        if visited is None:
            visited = set()

        if dependency.pk in visited:
            return False

        visited.add(dependency.pk)

        # Check if dependency points back to this task
        for dep_dep in dependency.dependencies.all():
            if dep_dep.pk == self.pk:
                return True
            if self._has_circular_dependency(dep_dep, visited):
                return True

        return False

    def can_execute(self):
        """
        Check if this task can be executed.

        A task can be executed if:
        - Its status is 'selected' or 'pending'
        - All its dependencies are completed

        Returns:
            bool: True if task can be executed.
        """
        if self.status not in ['selected', 'pending']:
            return False

        # Check all dependencies are completed
        incomplete_deps = self.dependencies.exclude(status='completed')
        return not incomplete_deps.exists()

    def get_blocking_dependencies(self):
        """
        Get the dependencies that are blocking this task.

        Returns:
            QuerySet: Dependencies that are not completed.
        """
        return self.dependencies.exclude(status='completed')

    def start_execution(self):
        """
        Mark the task as in progress.

        Returns:
            bool: True if transition was successful.

        Raises:
            ValidationError: If task cannot be executed.
        """
        if not self.can_execute():
            blocking = self.get_blocking_dependencies()
            if blocking.exists():
                raise ValidationError(
                    f'Tarefa bloqueada por dependencias: {", ".join([d.title for d in blocking])}'
                )
            raise ValidationError(
                f'Tarefa no status "{self.get_status_display()}" nao pode ser executada.'
            )

        self.status = 'in_progress'
        self.started_at = timezone.now()
        self.save(update_fields=['status', 'started_at', 'updated_at'])
        return True

    def mark_testing(self):
        """Mark the task as testing."""
        if self.status != 'in_progress':
            raise ValidationError('Somente tarefas em progresso podem entrar em teste.')

        self.status = 'testing'
        self.save(update_fields=['status', 'updated_at'])
        return True

    def mark_completed(self, commit_sha=''):
        """
        Mark the task as completed.

        Args:
            commit_sha: Optional git commit SHA.
        """
        if self.status not in ['in_progress', 'testing']:
            raise ValidationError('Somente tarefas em progresso ou teste podem ser concluidas.')

        self.status = 'completed'
        self.completed_at = timezone.now()
        if commit_sha:
            self.commit_sha = commit_sha

        # Calculate actual hours if started_at is set
        if self.started_at:
            duration = self.completed_at - self.started_at
            self.actual_hours = round(duration.total_seconds() / 3600, 2)

        self.save(update_fields=[
            'status', 'completed_at', 'commit_sha', 'actual_hours', 'updated_at'
        ])
        return True

    def mark_failed(self, error_message):
        """
        Mark the task as failed.

        Args:
            error_message: Description of what went wrong.
        """
        self.status = 'failed'
        self.error_message = error_message
        self.completed_at = timezone.now()
        self.save(update_fields=['status', 'error_message', 'completed_at', 'updated_at'])
        return True

    def skip(self, reason=''):
        """
        Skip this task.

        Args:
            reason: Optional reason for skipping.
        """
        self.status = 'skipped'
        if reason:
            self.error_message = f'Pulada: {reason}'
        self.save(update_fields=['status', 'error_message', 'updated_at'])
        return True

    def select(self):
        """Mark the task as selected for execution."""
        if self.status != 'pending':
            raise ValidationError('Somente tarefas pendentes podem ser selecionadas.')

        self.status = 'selected'
        self.save(update_fields=['status', 'updated_at'])
        return True

    def reset(self):
        """Reset the task to pending status."""
        self.status = 'pending'
        self.started_at = None
        self.completed_at = None
        self.error_message = ''
        self.commit_sha = ''
        self.actual_hours = None
        self.implementation = {}
        self.test_results = []
        self.save()
        return True

    @property
    def is_terminal(self):
        """Check if the task is in a terminal state."""
        return self.status in ['completed', 'failed', 'skipped']

    @property
    def is_active(self):
        """Check if the task is actively being worked on."""
        return self.status in ['in_progress', 'testing']

    @property
    def duration_seconds(self):
        """
        Calculate the duration of task execution in seconds.

        Returns:
            int or None: Duration in seconds, or None if not calculable.
        """
        if self.started_at and self.completed_at:
            return int((self.completed_at - self.started_at).total_seconds())
        return None

    @classmethod
    def get_next_order_index(cls, problem):
        """
        Get the next order index for a new task in a problem.

        Args:
            problem: The Problem instance.

        Returns:
            int: The next order index.
        """
        max_index = cls.objects.filter(problem=problem).aggregate(
            max_index=models.Max('order_index')
        )['max_index']
        return (max_index or 0) + 1


class TaskExecution(TimestampedModel):
    """
    TaskExecution model for logging task execution attempts.

    This model tracks individual execution attempts of a Task, including
    logs, outputs, errors, and timing information. Each Task can have
    multiple TaskExecution records, allowing for retry tracking and
    detailed audit trails.

    Attributes:
        id: UUID primary key
        task: The task being executed
        status: Current status of this execution attempt
        started_at: When this execution started
        completed_at: When this execution finished
        agent_type: Type of agent that performed the execution
        logs: Detailed execution logs
        output: Execution output/results
        error_message: Error details if execution failed
        metrics: JSON field for performance metrics
        attempt_number: Which attempt this is (for retries)
        celery_task_id: ID of the Celery task handling this execution
    """

    # Execution status choices
    STATUS_CHOICES = [
        ('pending', 'Pendente'),
        ('running', 'Executando'),
        ('completed', 'Concluido'),
        ('failed', 'Falhou'),
        ('cancelled', 'Cancelado'),
        ('timeout', 'Tempo Esgotado'),
    ]

    # Agent type choices
    AGENT_TYPE_CHOICES = [
        ('code_writer', 'Code Writer Agent'),
        ('test_runner', 'Test Runner Agent'),
        ('business_analyst', 'Business Analyst Agent'),
        ('tech_architect', 'Tech Architect Agent'),
        ('task_planner', 'Task Planner Agent'),
        ('unknown', 'Desconhecido'),
    ]

    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False
    )
    task = models.ForeignKey(
        Task,
        on_delete=models.CASCADE,
        related_name='executions',
        verbose_name='tarefa',
        help_text='Tarefa sendo executada'
    )
    status = models.CharField(
        'status',
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        db_index=True,
        help_text='Status atual desta execucao'
    )
    started_at = models.DateTimeField(
        'iniciado em',
        null=True,
        blank=True,
        help_text='Data e hora de inicio da execucao'
    )
    completed_at = models.DateTimeField(
        'concluido em',
        null=True,
        blank=True,
        help_text='Data e hora de conclusao da execucao'
    )
    agent_type = models.CharField(
        'tipo de agente',
        max_length=50,
        choices=AGENT_TYPE_CHOICES,
        default='unknown',
        help_text='Tipo de agente que executou a tarefa'
    )
    logs = models.TextField(
        'logs',
        blank=True,
        default='',
        help_text='Logs detalhados da execucao'
    )
    output = models.TextField(
        'saida',
        blank=True,
        default='',
        help_text='Saida/resultados da execucao'
    )
    error_message = models.TextField(
        'mensagem de erro',
        blank=True,
        default='',
        help_text='Detalhes do erro se a execucao falhou'
    )
    metrics = models.JSONField(
        'metricas',
        default=dict,
        blank=True,
        help_text='Metricas de performance em formato JSON'
    )
    attempt_number = models.PositiveIntegerField(
        'numero da tentativa',
        default=1,
        help_text='Numero da tentativa (para retries)'
    )
    celery_task_id = models.CharField(
        'ID da tarefa Celery',
        max_length=255,
        blank=True,
        default='',
        help_text='ID da tarefa Celery que esta executando'
    )

    class Meta:
        verbose_name = 'Execucao de Tarefa'
        verbose_name_plural = 'Execucoes de Tarefas'
        ordering = ['-created_at']
        db_table = 'tasks_execution'
        indexes = [
            models.Index(fields=['task', 'status']),
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['agent_type', 'status']),
            models.Index(fields=['celery_task_id']),
        ]

    def __str__(self):
        return f'{self.task.title} - Exec #{self.attempt_number} - {self.get_status_display()}'

    def start(self):
        """
        Mark this execution as running.

        Returns:
            bool: True if transition was successful.
        """
        if self.status != 'pending':
            raise ValidationError('Somente execucoes pendentes podem ser iniciadas.')

        self.status = 'running'
        self.started_at = timezone.now()
        self.save(update_fields=['status', 'started_at', 'updated_at'])
        return True

    def complete(self, output=''):
        """
        Mark this execution as completed successfully.

        Args:
            output: Optional output from the execution.
        """
        if self.status != 'running':
            raise ValidationError('Somente execucoes em andamento podem ser concluidas.')

        self.status = 'completed'
        self.completed_at = timezone.now()
        if output:
            self.output = output
        self.save(update_fields=['status', 'completed_at', 'output', 'updated_at'])
        return True

    def fail(self, error_message):
        """
        Mark this execution as failed.

        Args:
            error_message: Description of what went wrong.
        """
        self.status = 'failed'
        self.error_message = error_message
        self.completed_at = timezone.now()
        self.save(update_fields=['status', 'error_message', 'completed_at', 'updated_at'])
        return True

    def cancel(self):
        """Mark this execution as cancelled."""
        if self.status not in ['pending', 'running']:
            raise ValidationError('Somente execucoes pendentes ou em andamento podem ser canceladas.')

        self.status = 'cancelled'
        self.completed_at = timezone.now()
        self.save(update_fields=['status', 'completed_at', 'updated_at'])
        return True

    def mark_timeout(self):
        """Mark this execution as timed out."""
        self.status = 'timeout'
        self.error_message = 'Execucao excedeu o tempo limite'
        self.completed_at = timezone.now()
        self.save(update_fields=['status', 'error_message', 'completed_at', 'updated_at'])
        return True

    def append_log(self, message):
        """
        Append a message to the execution logs.

        Args:
            message: Log message to append.
        """
        timestamp = timezone.now().strftime('%Y-%m-%d %H:%M:%S')
        log_line = f'[{timestamp}] {message}\n'
        self.logs += log_line
        self.save(update_fields=['logs', 'updated_at'])

    @property
    def duration_seconds(self):
        """
        Calculate the duration of this execution in seconds.

        Returns:
            int or None: Duration in seconds, or None if not calculable.
        """
        if self.started_at and self.completed_at:
            return int((self.completed_at - self.started_at).total_seconds())
        return None

    @property
    def is_running(self):
        """Check if this execution is currently running."""
        return self.status == 'running'

    @property
    def is_terminal(self):
        """Check if this execution is in a terminal state."""
        return self.status in ['completed', 'failed', 'cancelled', 'timeout']

    @classmethod
    def create_for_task(cls, task, agent_type='unknown', celery_task_id=''):
        """
        Create a new execution record for a task.

        Args:
            task: The Task instance to create execution for.
            agent_type: Type of agent performing the execution.
            celery_task_id: Optional Celery task ID.

        Returns:
            TaskExecution: The created execution instance.
        """
        # Calculate attempt number based on previous executions
        attempt_number = task.executions.count() + 1

        return cls.objects.create(
            task=task,
            agent_type=agent_type,
            celery_task_id=celery_task_id,
            attempt_number=attempt_number
        )
